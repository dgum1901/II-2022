y <- log(carbohydrate$carbohydrate)
inv.XtX <- solve( XtX ) # solve returns the matrix inverse
XtY <- t(Xmat) %*% y
beta <- inv.XtX %*% XtY; drop(beta)
beta <- solve(XtX, XtY); beta
QR <- qr(Xmat)
beta <- qr.coef(QR, y); beta
mu <- Xmat %*% beta
RSS <- sum( (y - mu)^2 );
RSS
s2 <- RSS / ( length(carbohydrate$carbohydrate) - length(beta) )
c(s=sqrt(s2), s2=s2)
a<-predict(modelobase1,
interval = "confidence",
level = 0.90)
MsReg<-sqrt(mean((carbohydrate$carbohydrate - a[,1])^2))
Festadista<-MsReg/s2
Festadista<-MsReg/s2
DF <- df.residual(modelobase1);
DF
df.B <- df.residual(modelobase1);
df.B
pf(Festadista, df1=DF, df2=df.B, lower.tail=FALSE)
summary(modelobase1)
rstandard(modelobase1)#residual estandarizado
fitted(modelobase1) #Este ejemplo demuestra cómo encontrar los valores ajustados de un modelo de regresión lineal usando la función added().
cooks.distance(modelobase1) #La distancia de Cook es un resumen de cuánto cambia un modelo de regresión cuando se elimina la i-ésima observación
scatter.smooth( rstandard(modelobase1) ~ fitted(modelobase1) )
qqnorm( rstandard(modelobase1) )
qqline( rstandard(modelobase1) )
plot( cooks.distance(modelobase1), type="h")
influence.measures(modelobase1)$is.inf
rowSums(influence.measures(modelobase1)$is.inf)
plot(doctors$deaths/100000 ~ doctors$age)
plot(deaths/100000 ~ age, data=doctors)
plot(deaths/100000 ~ personyears, data=doctors)
plot(deaths/100000 ~doctors$`person-years`, data=doctors)
plot(deaths/100000 ~log(doctors$`person-years`), data=doctors)
plot(deaths/100000 ~log(doctors$`person-years`), data=doctors)
lines(deaths/100000  ~ log(doctors$`person-years`))
plot(deaths/100000 ~log(doctors$`person-years`), data=doctors)
lines(deaths/100000  ~ log(doctors$`person-years`),data=doctors)
plot(deaths/100000 ~doctors$`person-years`/100000, data=doctors)
plot(deaths/100000 ~doctors$`person-years`, data=doctors)
lines(deaths/100000  ~ log(doctors$`person-years`),data=doctors)
plot(deaths/100000 ~doctors$`person-years`, data=doctors)
lines(deaths/100000  ~ doctors$`person-years`,data=doctors)
plot(deaths/100000 ~log(doctors$`person-years`), data=doctors)
lines(deaths/100000  ~ log(doctors$`person-years`),data=doctors)
plot((doctors$`person-years`)/100000 ~age, data=doctors)
age
doctors$age
doctors$age <- belection%>%mutate(Party  = case_when( age == '35 to 44' ~ 0,
Party == '45 to 54n' ~ 1,
Party == '55 to 64' ~ 2,
Party == '65 to 74' ~ 3,
Party == '75 to 84' ~ 4),
)
library(dplyr)
doctors$age <- belection%>%mutate(Party  = case_when( age == '35 to 44' ~ 0,
Party == '45 to 54n' ~ 1,
Party == '55 to 64' ~ 2,
Party == '65 to 74' ~ 3,
Party == '75 to 84' ~ 4),
)
library(dplyr)
doctors$age <- doctors%>%mutate(age = case_when( age == '35 to 44' ~ 0,
age == '45 to 54n' ~ 1,
age == '55 to 64' ~ 2,
age == '65 to 74' ~ 3,
age == '75 to 84' ~ 4),
)
plot((doctors$`person-years`)/100000 ~age, data=doctors)
library(dplyr)
doctors$age <- doctors%>%mutate(age = case_when( age == '35 to 44' ~ 0,
age == '45 to 54n' ~ 1,
age == '55 to 64' ~ 2,
age == '65 to 74' ~ 3,
age == '75 to 84' ~ 4),
)
library(dplyr)
doctors <- doctors%>%mutate(age = case_when( age == '35 to 44' ~ 0,
age == '45 to 54n' ~ 1,
age == '55 to 64' ~ 2,
age == '65 to 74' ~ 3,
age == '75 to 84' ~ 4),
)
doctors
library(dplyr)
doctors <- doctors%>%mutate(age = case_when( age == '35 to 44' ~ 0,
age == '45 to 54' ~ 1,
age == '55 to 64' ~ 2,
age == '65 to 74' ~ 3,
age == '75 to 84' ~ 4),
)
knitr::opts_chunk$set(echo = TRUE)
library(readr)
carbohydrate <- read_csv("carbohydrate.csv")
plot(carbohydrate$carbohydrate~carbohydrate$age)
plot( carbohydrate~ age, data = carbohydrate)
plot(carbohydrate ~ weight, data = carbohydrate)
plot(carbohydrate ~ protein, data = carbohydrate)
summary(carbohydrate)
var(carbohydrate$age)
var(carbohydrate$carbohydrate)
var(carbohydrate$weight)
var(carbohydrate$protein)
min.model <- lm(carbohydrate ~ age +weight+protein, data=carbohydrate)
max.model <- lm( carbohydrate ~ (protein+weight+age)^2, data=carbohydrate)
auto.forward <- step( min.model, direction="forward",
scope=list(lower=min.model, upper=max.model) )
signif( coef(auto.forward), 3 )
modelobase1<-lm(carbohydrate ~ weight+protein, data=carbohydrate)
summary(modelobase1)
coef(modelobase1)
confint(modelobase1, level = 0.9)
Xmat<-model.matrix( ~ weight+protein,
data=carbohydrate)
XtX <- t(Xmat) %*% Xmat # t() is transpose; %*% is matrix multiply
y <- log(carbohydrate$carbohydrate)
inv.XtX <- solve( XtX ) # solve returns the matrix inverse
XtY <- t(Xmat) %*% y
beta <- inv.XtX %*% XtY; drop(beta)
beta <- solve(XtX, XtY); beta
QR <- qr(Xmat)
beta <- qr.coef(QR, y); beta
mu <- Xmat %*% beta
RSS <- sum( (y - mu)^2 );
RSS
s2 <- RSS / ( length(carbohydrate$carbohydrate) - length(beta) )
c(s=sqrt(s2), s2=s2)
a<-predict(modelobase1,
interval = "confidence",
level = 0.90)
MsReg<-sqrt(mean((carbohydrate$carbohydrate - a[,1])^2))
Festadista<-MsReg/s2
Festadista<-MsReg/s2
DF <- df.residual(modelobase1);
DF
df.B <- df.residual(modelobase1);
df.B
pf(Festadista, df1=DF, df2=df.B, lower.tail=FALSE)
summary(modelobase1)
# x <-(PromedioTemperatura = seq(min(x), max(x), by = 0.05))
# cosa <-
#   predict(mod_leo,
#           newdata = data.frame(x),
#           interval = "confidence",
#           level = 0.90)
rstandard(modelobase1)#residual estandarizado
fitted(modelobase1) #Este ejemplo demuestra cómo encontrar los valores ajustados de un modelo de regresión lineal usando la función added().
cooks.distance(modelobase1) #La distancia de Cook es un resumen de cuánto cambia un modelo de regresión cuando se elimina la i-ésima observación
scatter.smooth( rstandard(modelobase1) ~ fitted(modelobase1) )
qqnorm( rstandard(modelobase1) )
qqline( rstandard(modelobase1) )
plot( cooks.distance(modelobase1), type="h")
influence.measures(modelobase1)$is.inf
rowSums(influence.measures(modelobase1)$is.inf)
library(readr)
doctors <- read_csv("doctors.csv")
group_by(age)
group_by(doctors$age)
doctor$age
doctors$age
library(dplyr)
doctors1 <- doctors%>%mutate(age = case_when( age == '35 to 44' ~ 0,
age == '45 to 54' ~ 1,
age == '55 to 64' ~ 2,
age == '65 to 74' ~ 3,
age == '75 to 84' ~ 4),
)
plot((doctors$`person-years`)/100000 ~age, data=doctors)
library(dplyr)
doctors1 <- doctors%>%mutate(age = case_when( age == '35 to 44' ~ 0,
age == '45 to 54' ~ 1,
age == '55 to 64' ~ 2,
age == '65 to 74' ~ 3,
age == '75 to 84' ~ 4),
)
plot((doctors$`person-years`)/100000 ~age, data=doctors1)
lines((doctors$`person-years`)/100000  ~ age,data=doctors1)
library(dplyr)
doctors1 <- doctors%>%mutate(age = case_when( age == '35 to 44' ~ 0,
age == '45 to 54' ~ 1,
age == '55 to 64' ~ 2,
age == '65 to 74' ~ 3,
age == '75 to 84' ~ 4),
)
plot((doctors$`person-years`)/100000 ~age, data=doctors1)
plot( doctors1$smoking~age, data=doctors1)
plot( smoking~age, data=doctors1)
plot( age~smoking, data=doctors1)
barplot(smoking~age, data=doctors1)
plot( smoking~age, data=doctors1)
doctors2 <- doctors1%>%mutate(age = case_when( smoking == 'non-smoker' ~ 0,
smoking == 'smoker' ~ 1
)
plot( smoking~age, data=doctors1)
doctors2 <- doctors1%>%mutate(smoking = case_when( smoking == 'non-smoker' ~ 0,
smoking == 'smoker' ~ 1)
plot( smoking~age, data=doctors2)
doctors2 <- doctors1%>%mutate(smoking = case_when( smoking == 'non-smoker' ~ 0,
smoking == 'smoker' ~ 1))
plot( smoking~age, data=doctors2)
doctors2 <- doctors1%>%mutate(smoking = case_when( smoking == 'non-smoker' ~ 0,
smoking == 'smoker' ~ 1))
plot( smoking~age, data=doctors2)
knitr::opts_chunk$set(echo = TRUE)
library(readr)
carbohydrate <- read_csv("carbohydrate.csv")
plot(carbohydrate$carbohydrate~carbohydrate$age)
plot( carbohydrate~ age, data = carbohydrate)
plot(carbohydrate ~ weight, data = carbohydrate)
plot(carbohydrate ~ protein, data = carbohydrate)
summary(carbohydrate)
var(carbohydrate$age)
var(carbohydrate$carbohydrate)
var(carbohydrate$weight)
var(carbohydrate$protein)
min.model <- lm(carbohydrate ~ age +weight+protein, data=carbohydrate)
max.model <- lm( carbohydrate ~ (protein+weight+age)^2, data=carbohydrate)
auto.forward <- step( min.model, direction="forward",
scope=list(lower=min.model, upper=max.model) )
signif( coef(auto.forward), 3 )
modelobase1<-lm(carbohydrate ~ weight+protein, data=carbohydrate)
summary(modelobase1)
coef(modelobase1)
confint(modelobase1, level = 0.9)
Xmat<-model.matrix( ~ weight+protein,
data=carbohydrate)
XtX <- t(Xmat) %*% Xmat # t() is transpose; %*% is matrix multiply
y <- log(carbohydrate$carbohydrate)
inv.XtX <- solve( XtX ) # solve returns the matrix inverse
XtY <- t(Xmat) %*% y
beta <- inv.XtX %*% XtY; drop(beta)
beta <- solve(XtX, XtY); beta
QR <- qr(Xmat)
beta <- qr.coef(QR, y); beta
mu <- Xmat %*% beta
RSS <- sum( (y - mu)^2 );
RSS
s2 <- RSS / ( length(carbohydrate$carbohydrate) - length(beta) )
c(s=sqrt(s2), s2=s2)
a<-predict(modelobase1,
interval = "confidence",
level = 0.90)
MsReg<-sqrt(mean((carbohydrate$carbohydrate - a[,1])^2))
Festadista<-MsReg/s2
Festadista<-MsReg/s2
DF <- df.residual(modelobase1);
DF
df.B <- df.residual(modelobase1);
df.B
pf(Festadista, df1=DF, df2=df.B, lower.tail=FALSE)
summary(modelobase1)
# x <-(PromedioTemperatura = seq(min(x), max(x), by = 0.05))
# cosa <-
#   predict(mod_leo,
#           newdata = data.frame(x),
#           interval = "confidence",
#           level = 0.90)
rstandard(modelobase1)#residual estandarizado
fitted(modelobase1) #Este ejemplo demuestra cómo encontrar los valores ajustados de un modelo de regresión lineal usando la función added().
cooks.distance(modelobase1) #La distancia de Cook es un resumen de cuánto cambia un modelo de regresión cuando se elimina la i-ésima observación
scatter.smooth( rstandard(modelobase1) ~ fitted(modelobase1) )
qqnorm( rstandard(modelobase1) )
qqline( rstandard(modelobase1) )
plot( cooks.distance(modelobase1), type="h")
influence.measures(modelobase1)$is.inf
rowSums(influence.measures(modelobase1)$is.inf)
library(readr)
doctors <- read_csv("doctors.csv")
library(dplyr)
doctors1 <- doctors%>%mutate(age = case_when( age == '35 to 44' ~ 0,
age == '45 to 54' ~ 1,
age == '55 to 64' ~ 2,
age == '65 to 74' ~ 3,
age == '75 to 84' ~ 4),
)
plot((doctors$`person-years`)/100000 ~age, data=doctors1)
library(dplyr)
doctors1 <- doctors%>%mutate(age = case_when( age == '35 to 44' ~ 1,
age == '45 to 54' ~ 2,
age == '55 to 64' ~ 3,
age == '65 to 74' ~ 4,
age == '75 to 84' ~ 5)
)
plot((doctors$`person-years`)/100000 ~age, data=doctors1)
modelopos<- glm((doctors1$deaths)/100000 ~ age + smoking, family=poisson,
data=doctors1 )
modelopos
plot( cbind(smoker, no-smoker) ~age, data=doctors2)
knitr::opts_chunk$set(echo = TRUE)
library(readr)
carbohydrate <- read_csv("carbohydrate.csv")
plot(carbohydrate$carbohydrate~carbohydrate$age)
plot( carbohydrate~ age, data = carbohydrate)
plot(carbohydrate ~ weight, data = carbohydrate)
plot(carbohydrate ~ protein, data = carbohydrate)
summary(carbohydrate)
var(carbohydrate$age)
var(carbohydrate$carbohydrate)
var(carbohydrate$weight)
var(carbohydrate$protein)
min.model <- lm(carbohydrate ~ age +weight+protein, data=carbohydrate)
max.model <- lm( carbohydrate ~ (protein+weight+age)^2, data=carbohydrate)
auto.forward <- step( min.model, direction="forward",
scope=list(lower=min.model, upper=max.model) )
signif( coef(auto.forward), 3 )
modelobase1<-lm(carbohydrate ~ weight+protein, data=carbohydrate)
summary(modelobase1)
coef(modelobase1)
confint(modelobase1, level = 0.9)
Xmat<-model.matrix( ~ weight+protein,
data=carbohydrate)
XtX <- t(Xmat) %*% Xmat # t() is transpose; %*% is matrix multiply
y <- log(carbohydrate$carbohydrate)
inv.XtX <- solve( XtX ) # solve returns the matrix inverse
XtY <- t(Xmat) %*% y
beta <- inv.XtX %*% XtY; drop(beta)
beta <- solve(XtX, XtY); beta
QR <- qr(Xmat)
beta <- qr.coef(QR, y); beta
mu <- Xmat %*% beta
RSS <- sum( (y - mu)^2 );
RSS
s2 <- RSS / ( length(carbohydrate$carbohydrate) - length(beta) )
c(s=sqrt(s2), s2=s2)
a<-predict(modelobase1,
interval = "confidence",
level = 0.90)
MsReg<-sqrt(mean((carbohydrate$carbohydrate - a[,1])^2))
Festadista<-MsReg/s2
Festadista<-MsReg/s2
DF <- df.residual(modelobase1);
DF
df.B <- df.residual(modelobase1);
df.B
pf(Festadista, df1=DF, df2=df.B, lower.tail=FALSE)
summary(modelobase1)
# x <-(PromedioTemperatura = seq(min(x), max(x), by = 0.05))
# cosa <-
#   predict(mod_leo,
#           newdata = data.frame(x),
#           interval = "confidence",
#           level = 0.90)
rstandard(modelobase1)#residual estandarizado
fitted(modelobase1) #Este ejemplo demuestra cómo encontrar los valores ajustados de un modelo de regresión lineal usando la función added().
cooks.distance(modelobase1) #La distancia de Cook es un resumen de cuánto cambia un modelo de regresión cuando se elimina la i-ésima observación
scatter.smooth( rstandard(modelobase1) ~ fitted(modelobase1) )
qqnorm( rstandard(modelobase1) )
qqline( rstandard(modelobase1) )
plot( cooks.distance(modelobase1), type="h")
influence.measures(modelobase1)$is.inf
rowSums(influence.measures(modelobase1)$is.inf)
library(readr)
doctors <- read_csv("doctors.csv")
library(dplyr)
doctors1 <- doctors%>%mutate(age = case_when( age == '35 to 44' ~ 1,
age == '45 to 54' ~ 2,
age == '55 to 64' ~ 3,
age == '65 to 74' ~ 4,
age == '75 to 84' ~ 5)
)
plot((doctors$`person-years`)/100000 ~age, data=doctors1)
plot( cbind(smoker, no-smoker) ~age, data=doctors1)
plot( filter(smoking) ~age, data=doctors1)
plot( gropu_by(smoking)) ~age, data=doctors1)
plot(smoking) ~age, data=doctors1)
glm(formula = (doctors1$deaths)/100000  ~ age+smoking, family = binomial,
data = doctors1, weights = doctors1$`person-years`)
modelopos<- glm((doctors1$deaths)/100000 ~ age + smoking, family=poisson,
data=doctors1 )
modelopos
min(doctors1$deaths)
fit10.11quasi <- glm( (doctors1$deaths)/100000 ~ offset(log(doctors1$`person-years`) )+age + smoking,
family="quasipoisson", data=doctors1)
summary(fit10.11quasi)
plot(fit10.11quasi)
influence.measures(fit10.11quasi)$is.inf
printCoefmat(exp(coef(summary(fit10.11quasi))),digits=4)
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
library(tidyverse)
require("knitcitations")
require("bibtex")
library(rmdformats)
library(readxl)
library(plyr)
library(dplyr)
library(fOptions)
library(ggplot2)
library(kableExtra)
library(extrafont)
options(max.print="75")
opts_chunk$set(echo=FALSE,
cache=TRUE,
prompt=FALSE,
tidy=TRUE,
comment=NA,
message=FALSE,
warning=FALSE)
opts_knit$set(width=75)
options(tinytex.verbose = TRUE)
library(readr)
data <- read_csv("data.csv")
library(xtable)
(data <- tibble(data))
p <- data %>% tibble() %>% select(is.numeric & !yr_built & !yr_renovated & !view & !waterfront)
a <- t(mapply(p, FUN = summary))
xtable(a)
a <- tibble(Desviacion = mapply(p, FUN = sd), IQR = mapply(p, FUN = IQR))
rownames(a) <- colnames(p)
#Se le pone doble transpuesta porque por algún motivo así acepta el formato
xtable(t(t(a)))
#Es la misma tabla de álgebra 1 xd
tablaDatos <- function(datos, columna){
x <- as.numeric(datos[[columna]]) #Acá tira warning por NA en el vector, pero no afecta
x <- x[!is.na(x)] #Aca se arregla
s <- sd(x)
n <- length(x)
# Usamos el h mas robusto normal
h <- 1.06 * min(s, IQR(x)/1.34) * n^(-1/5)
n <- floor(diff(range(x))/h)
breaks <- seq(from = min(x), to = max(x), by = (max(x)-min(x))/n) #9 subintervalos
breaks[1] <- breaks[1]-0.01 #Para que incluya al primer elemento
x<-tibble(variable = x)
tabla <- x %>% group_by(variable) %>%
mutate(
variable = cut(variable, breaks  = breaks)
) %>%
dplyr::summarise(frequency = n()) %>%
mutate(cum_frequency = cumsum(frequency))
tabla$rf <- tabla$frequency/sum(tabla$frequency)
tabla$'crf(%)' <- cumsum(tabla$rf)*100
tabla$'rf(%)' <- tabla$rf*100
colnames(tabla)[1:3]<- c("Intervalo","f","cf")
tabla<-tabla %>% mutate_if(is.numeric, ~round(., 2))
tabla
}
#Precio
dt<-tablaDatos(data,2)
xtable(dt)
#Tamano construccion
dt<-tablaDatos(data,11)
xtable(dt)
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
library(tidyverse)
require("knitcitations")
require("bibtex")
library(rmdformats)
library(readxl)
library(plyr)
library(dplyr)
library(fOptions)
library(ggplot2)
library(kableExtra)
library(extrafont)
options(max.print="75")
opts_chunk$set(echo=FALSE,
cache=TRUE,
prompt=FALSE,
tidy=TRUE,
comment=NA,
message=FALSE,
warning=FALSE)
opts_knit$set(width=75)
options(tinytex.verbose = TRUE)
library(readr)
data <- read_csv("data.csv")
library(xtable)
(data <- tibble(data))
p <- data %>% tibble() %>% select(is.numeric & !yr_built & !yr_renovated & !view & !waterfront)
a <- t(mapply(p, FUN = summary))
xtable(a)
a <- tibble(Desviacion = mapply(p, FUN = sd), IQR = mapply(p, FUN = IQR))
rownames(a) <- colnames(p)
#Se le pone doble transpuesta porque por algún motivo así acepta el formato
xtable(t(t(a)))
#Es la misma tabla de álgebra 1 xd
tablaDatos <- function(datos, columna){
x <- as.numeric(datos[[columna]]) #Acá tira warning por NA en el vector, pero no afecta
x <- x[!is.na(x)] #Aca se arregla
s <- sd(x)
n <- length(x)
# Usamos el h mas robusto normal
h <- 1.06 * min(s, IQR(x)/1.34) * n^(-1/5)
n <- floor(diff(range(x))/h)
breaks <- seq(from = min(x), to = max(x), by = (max(x)-min(x))/n) #9 subintervalos
breaks[1] <- breaks[1]-0.01 #Para que incluya al primer elemento
x<-tibble(variable = x)
tabla <- x %>% group_by(variable) %>%
mutate(
variable = cut(variable, breaks  = breaks)
) %>%
dplyr::summarise(frequency = n()) %>%
mutate(cum_frequency = cumsum(frequency))
tabla$rf <- tabla$frequency/sum(tabla$frequency)
tabla$'crf(%)' <- cumsum(tabla$rf)*100
tabla$'rf(%)' <- tabla$rf*100
colnames(tabla)[1:3]<- c("Intervalo","f","cf")
tabla<-tabla %>% mutate_if(is.numeric, ~round(., 2))
tabla
}
#Precio
dt<-tablaDatos(data,2)
xtable(dt)
#Tamano construccion
dt<-tablaDatos(data,11)
xtable(dt)
View(data)
